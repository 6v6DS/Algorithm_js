## 콜라 문제
#### 프로그래머스 lv.1 132267
------
* 문제

오래전 유행했던 콜라 문제가 있습니다. 콜라 문제의 지문은 다음과 같습니다.

> 정답은 아무에게도 말하지 마세요.

> 콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다. 빈 병 20개를 가져다주면 몇 병을 받을 수 있는가?

> 단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다.

문제를 풀던 상빈이는 콜라 문제의 완벽한 해답을 찾았습니다. 

상빈이가 푼 방법은 아래 그림과 같습니다. 

우선 콜라 빈 병 20병을 가져가서 10병을 받습니다. 

받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다. 

5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고, 또 2병을 모두 마신 뒤 가져가서 1병을 받습니다. 

받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다. 

이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다.

------

문제를 열심히 풀던 상빈이는 일반화된 콜라 문제를 생각했습니다. 

이 문제는 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하는 문제입니다. 

기존 콜라 문제와 마찬가지로, 보유 중인 빈 병이 a개 미만이면, 추가적으로 빈 병을 받을 순 없습니다. 

상빈이는 열심히 고심했지만, 일반화된 콜라 문제의 답을 찾을 수 없었습니다. 

상빈이를 도와, 일반화된 콜라 문제를 해결하는 프로그램을 만들어 주세요.

------

콜라를 받기 위해 마트에 주어야 하는 병 수 a, 빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b, 상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다. 

상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요.

* 제한 조건

1 ≤ b < a ≤ n ≤ 1,000,000

정답은 항상 int 범위를 넘지 않게 주어집니다.

* 입출력 예

입력 

|a|b|n|result|
|------|---|-----|
|2|1|20|19|
|3|1|20|9|


-----

* 나의 코드
```
function solution(a, b, n) {    
    let result = 0;
    let M = 0;
    let left = 0;
    let answer = [];
    
    for(;;){
        M = Math.floor(n/a);
        left = n - (a * M);
        result = b*M;
        answer.push(result);
        n = result + left;
        if(n < a){
            break;
        }
    }
    
    let sum = 0;
    answer.forEach((e) => {
        sum = sum + e;
    })
    
    return sum;
}



```
----
* 실수

초반에는 문제 설계를 다음과 같이 작성한 후 코드를 짰다.
```
반복문 n이 음수가 되기 전까지 반복
n = 몫(n / a) // 총 n의 수를 a로 나눠 몫을 구한다
M = answer % a; // 남은 병의 수를 구하여 M에 할당한다
answer = n + M; // 현재 가지고 있는 병의 수를 받은 병의 수 + 남은 병의 수 하여 구한다
합 = 합 + n; // 최종 병의 수를 구한다
```
이런 식으로 코드를 작성하였다
```
function solution(a, b, n) {
    //a = 한번에 가져다줘야하는 병 수
    //b = 마트가 주는 병 수
    //n = 상빈이 병 수
    // 2 1 20 = 19 -> 20 / 2 = 10, 10 / 2 = 5, 5 / 2 = 2(1), 3 / 2 = 1(1), 2/2 = 1; 
    // 3 1 20 = 9 -> 20 / 3 = 6(2), 8 / 3 = 2(2), 4 / 3 = 1(1);
    let answer = n;
    let M = 0;
    let sum = 0;
    
    for(n; n > 0;){      
        n = Math.floor(answer / a);
        M = answer % a;
        answer = n + M;
        sum = sum + n;
        console.log(sum);
    }

    return sum;
}
```
테스트케이스 2개는 충족하였지만, 제출을 해보니 맨 밑 2개의 테스트케이스 외에는 모두 충족하지 못했다.

충족하지 않았던 이유는, b의 값을 고려하지 않고 1으로 가정하고 몫을 도출했기 때문이다.

예를 들어, 입력 값이 a = 5, b = 3, n = 21인 경우 b가 3이기 때문에 위의 코드에서는 원하는 출력값이 나오지 않았다.

따라서 맨 처음부터 설계를 다시 진행하였다.

```
반복문 n이 a보다 작을 경우 반복문 종료
1. M = Math.floor(n/a); // 곱하는 수를 구한다
2. left = n - (a * M); // 남은 병의 수를 구한다
3. result = b * M; // b의 수를 고려하여 받는 병의 수를 구한다
4. n = result + left; // 현재 소유하고 있는 병의 수를 구한다
```
이와 같은 설계로 정답을 도출하였다.

`for(;;)`이 아닌, `while`문으로 코드를 수정할 수 있을 것 같아 코드를 수정해보았다.

* 개선 코드
```
function solution(a, b, n) {    
    let result = 0;
    let M = 0;
    let left = 0;
    let answer = [];
    
    while(n >= a){
        M = Math.floor(n/a);
        left = n - (a * M);
        result = b*M;
        answer.push(result);
        n = result + left;
    }
    
    let sum = 0;
    answer.forEach((e) => {
        sum = sum + e;
    })
    
    return sum;
}

```