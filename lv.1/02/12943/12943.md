## 콜라츠 추측
#### 프로그래머스 lv.1 12943
------
* 문제

1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.

1-1.입력된 수가 짝수라면 2로 나눕니다. 

1-2.입력된 수가 홀수라면 3을 곱하고 1을 더합니다.

2.결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 

예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.

* 제한 조건

입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.

* 입출력 예

|n|answer|
|------|---|
|6|8|
|16|4|
|626331|-1|

-----
* 나의 코드

```
function solution(num) {
    var count = 0;
    if(num < 1 || num > 8000000){
        return 0;
    }
    if(num == 1){
        return 0;
    }
    
    for(let i=0; i< 500; i++){
        if(num % 2 == 0){
            num = num / 2;
            count++;
            if(num == 1){
                return count;
            }
        }else{
            num = num * 3 + 1;
            count++;
            if(num == 1){
                return count;
            }
        }
        if(i == 499){
            return -1;
        }
    }

}
```
----
* 느낀점

조건부 연산자를 사용하면 코드를 더 간결하게 줄일 수 있다! 조건 연산자는 세 개의 피연산자를 받는 연산자이다. 앞에서부터 조건문, 물음표(?), 조건문이 참일 경우 실행할 표현식, 콜론(:), 조건문이 거짓(falsy)일 경우 실행할 표현식이 배치된다. `condition ? exprIfTrue : exprIfFalse;`

조건부 연산자를 사용하는 방식으로 코드를 수정해보았다.

* 개선 코드

```
function solution(num) {
    var count = 0;
    if(num < 1 || num > 8000000){
        return 0;
    }
    if(num == 1){
        return 0;
    }
    
    
    for(let i=0; i< 500; i++){
        if(num == 1){
            return count;
        }
        count++;
        num = num % 2 == 0 ? num / 2 : num * 3 + 1; 
    }
    
    return -1;
}
```
테스트 케이스 속도 또한 더 빨라졌다.

* 실수

테스트케이스 한 개가 실패여서 예외 처리를 다시 살펴봤더니, 주어진 수가 1인 경우에는 0을 리턴하는 점을 놓쳤었다. 예외처리를 추가해서 통과하였다. 주어진 조건을 명확히 살피는 것이 중요할 것 같다. 주어진 테스트케이스가 통과했다고 해서 모두 성공은 아니라는 점을 간과하지 말자!